<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux基础</title>
    <url>/2021/08/26/Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Linux基础</p>
<p>2021年5月12日</p>
<p>21:02</p>
<p>快捷键与命令</p>
<span id="more"></span>

<p>Poweroff  关机</p>
<p>Reboddot   重启</p>
<p>Pwd   —-当前目录</p>
<p>ctrl+l  —-清屏  </p>
<p>File —-查看文件信息</p>
<p>Man 命令 —帮助手册</p>
<p>Du —–查看目录信息</p>
<p>服务</p>
<p>systemctl –type=service  ——查看所有服务状态</p>
<p>service xxx start  ——-启动服务</p>
<p>ss -antpl                   —–查看端口</p>
<p>systemctl stop firewalld.service  —–关闭防火墙</p>
<p><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20210826155402.png" alt="操作系统文件类型"></p>
<p>文件类型</p>
<p>蓝色–目录</p>
<p>黑色–普通文件</p>
<p>浅蓝色–符号链接(快捷方式)</p>
<p>黑底黄字—设备文件 硬盘 Sda</p>
<p>绿色—-有执行权限文件</p>
<p>红色—-压缩包</p>
<p>紫色—图片 模块文件</p>
<p>/bin 普通用户与管理员都可运行的命令</p>
<p>/sbin 只有管理员运行 关机重启</p>
<p>/boot 引导主引导目录 独立的分区 启动菜单 内核</p>
<p>/dev device设备 设备文件存放目录</p>
<p>/etc 配置文件目录</p>
<p>/home 普通用户家</p>
<p>/root 管理员家</p>
<p>/media 光驱的挂载目录</p>
<p>/mnt 临时设备挂载目录 U盘</p>
<p>/proc 数据在内存中，进程所在目录</p>
<p>/tmp 临时文件目录</p>
<p>/usr 软件按照目录</p>
<p>/var 常变文件存放目录，日志，邮件</p>
<p>增删改查</p>
<p>查询: 目录下文件  文件中内容</p>
<p>Ls   cat </p>
<p>Ls - a  隐藏文件</p>
<p><code>    </code>-l 详细信息</p>
<p><code>    </code>-h 人性化信息</p>
<p><code>    </code>-R 递归显示</p>
<p>创建： 创建文件 目录 符号链接</p>
<p>Touch  文件名  </p>
<p>Echo “hello” &gt; 文件</p>
<p>Mkdir 目录</p>
<p>Ln -s 绝对路径源文件 建立的链接文件</p>
<p>改：剪切，复制</p>
<p>Mv 剪切，改名</p>
<p>Cp  复制</p>
<p>删除</p>
<p>rm 删除 -f 强制删除 -r 递归删除目录</p>
<p>压缩</p>
<p>Gzip 文件名称 解压 gunzip 文件名称</p>
<p>Bzip2 文件名称  解压 bunzip2 文件名称</p>
<p><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20210826155418.png" alt="目录打包工具"></p>
<p>目录打包工具</p>
<p>Tar -cf 新文件目录 源文件目录</p>
<p>-tvf 不解包情况下观看包情况</p>
<p>内部命令： 命令解释器自带命令 help cd</p>
<p>外面命令:  外部应用携带命令 man ls</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux帐户安全</title>
    <url>/2021/08/26/Linux%E5%B8%90%E6%88%B7%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>Linux帐号安全</p>
<p>2021年8月26日</p>
<p>16:12</p>
<h2 id="linux中用户分类及信息保存位置"><a href="#linux中用户分类及信息保存位置" class="headerlink" title="linux中用户分类及信息保存位置"></a><strong>linux中用户分类及信息保存位置</strong></h2><ul>
<li>Root超级管理员</li>
<li>普通用户 :权限比管理员低也可以登录系统<span id="more"></span></li>
<li>程序用户   ：无法登录系统</li>
</ul>
<h3 id="用户分类和组信息"><a href="#用户分类和组信息" class="headerlink" title="用户分类和组信息"></a><strong>用户分类和组信息</strong></h3><h4 id="etc-passwd-保存了系统中所有用户信息"><a href="#etc-passwd-保存了系统中所有用户信息" class="headerlink" title="/etc/passwd 保存了系统中所有用户信息"></a><em><strong>/etc/passwd 保存了系统中所有用户信息</strong></em></h4><p><code> </code>root : x : 0 : 0: root : /root : /bin/bash</p>
<p><code> </code>字段1:用户名</p>
<p><code> </code>字段2:密码占位符</p>
<p><code> </code>字段3:用户uid 0表示超级用户 500-60000普通用户 , 1-499程序用户：无法登录系统<br><code>  </code>字段4: 组gid  先有组才有用户        </p>
<p><code> </code>字段5:用户信息记录字段</p>
<p><code> </code>字段6:用户家目录</p>
<p><code> </code>字段7:用户登录系统后使用命令解释器</p>
<h4 id="etc-shadow保存用户密码信息"><a href="#etc-shadow保存用户密码信息" class="headerlink" title="/etc/shadow保存用户密码信息"></a><em><strong>/etc/shadow保存用户密码信息</strong></em></h4><p>root : $6$V8sVLSI7G4vw7YzND3gJANtFD1NkbY4. : : 0 :99999:7: : :</p>
<p>字段1:用户名</p>
<p>字段2:密码  SHA-512</p>
<p>字段3:距离1970/1/1密码最近一次修改时间</p>
<p>字段4:密码最短有效期</p>
<p>字段5:密码最长有效期 建议为90天</p>
<p>字段6:密码过期前7天警告</p>
<p>字段7:密码不活跃期</p>
<p>字段8:用户失效时间</p>
<h4 id="etc-group-系统所有组信息"><a href="#etc-group-系统所有组信息" class="headerlink" title="/etc/group 系统所有组信息"></a><em><strong>/etc/group 系统所有组信息</strong></em></h4><p>root:x:0: </p>
<h2 id="建立及调整组用户属性"><a href="#建立及调整组用户属性" class="headerlink" title="建立及调整组用户属性"></a><strong>建立及调整组用户属性</strong></h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a><strong>命令</strong></h3><p>groupadd xxx 添加组</p>
<p>groupmod -g 1000 xxxx 修改组gid</p>
<p>groupadd -g 2000 yyyy 建立组gid 2000</p>
<p>useradd -g xxxx or 1000 tom 建立用户属于组1000</p>
<p>id tom       查看用户信息</p>
<p>usermod -G 2000 or yyyy tom -u 600 tom  -G添加附加组 -u 修改uid</p>
<p>useradd -u 250 -M -s /sbin/nologin testuser  -M没有家目录2 -s指定命令解释器</p>
<p>passwd tom   设置密码</p>
<p>change -M  90 tome  设置密码最长有效期 90天</p>
<p>passwd -S tom 用户密码信息</p>
<p>passwd -l tom 锁定用户禁止登录</p>
<p>passwd -u tom 解锁用户</p>
<p>userdel -r tom 删除用户  -r删除家目录</p>
<p>groupdel xxxx  删除组</p>
<h2 id="设置文件目录权限"><a href="#设置文件目录权限" class="headerlink" title="设置文件目录权限"></a><strong>设置文件目录权限</strong></h2><h3 id="权限解释"><a href="#权限解释" class="headerlink" title="权限解释"></a><strong>权限解释</strong></h3><p>-rw-r–r–. 1(当前几个节点) root(所属者) root(所属组) test.txt文件</p>
<p>drwxr-xr-x. 2 root root  Downloads/ 目录</p>
<p>- rw- r– r– .</p>
<p>d rwx r-x r-x .</p>
<p>字段1:文件类型 -普通文件 d目录 l符号链接 b块设备</p>
<p>字段2:文件所属者对文件的权限</p>
<p>r                           w                  x</p>
<p>文件: read读取文件 write写文件 可执行权限</p>
<p>目录: read查看目录  增删文件      进入目录</p>
<p>字段3:文件所属组权限</p>
<p>字段4:其他用户权限0</p>
<p>粘滞位 sgid suid 权限</p>
<p>粘滞位针对目录进行赋权,目录中创建文件只有建立者可以删除 ：一般在tem目录中具有</p>
<p>sgid 针对目录建立的权限，在该目录中建立文件所属组权限继承父目录</p>
<p>suid 对可执行文件建立权限，谁执行该文件，具有该文件所属者权限</p>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a><strong>命令</strong></h3><p>查看文件权限 ls -l</p>
<p>查看目录权限 ls -ld</p>
<p>chmod 对象 算术运算符 权限 文件     :改变文件权限</p>
<p>用户: u (所属者) g(所属组) o（其他用户） a(all)</p>
<p>算术运算符: - + =</p>
<p>权限: r w x</p>
<p>chown 用户 文件   :改变所属用户</p>
<p>chgrp 组 文件         :改变所属组</p>
<p>chmod 764 test.txt</p>
<p>7:8进制赋权 111 所属者</p>
<p>6:                   001 所属组</p>
<p>4:                    010 其他用户</p>
<p>chmod o +t 粘滞位权限</p>
<p>chmod o+s suid 权限</p>
<h2 id="安全相关指令"><a href="#安全相关指令" class="headerlink" title="安全相关指令"></a><strong>安全相关指令</strong></h2><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a><strong>命令</strong></h3><p>chattr +i /etc/passwd /etc/shadow :文件不可更改</p>
<p>umask 权限掩码   0022   创建 0777-0022 =  0755</p>
<p>在/etc/profile 和 /etc/bashrc中更改</p>
<p>/etc/login.defs 用户有关密码信息默认配置信息</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux日志基础</title>
    <url>/2021/08/28/Linux%E6%97%A5%E5%BF%97%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Linux日志基础</p>
<p>2021年8月28日</p>
<p>17:36</p>
<span id="more"></span>

<h2 id="网络信息查看与配置"><a href="#网络信息查看与配置" class="headerlink" title="网络信息查看与配置"></a><strong>网络信息查看与配置</strong></h2><h3 id="临时配置"><a href="#临时配置" class="headerlink" title="临时配置"></a><strong>临时配置</strong></h3><p>ip addr 确认系统网卡信息</p>
<p>service NetworkManager stop 关闭networkmanager服务</p>
<p>ip addr add 10.1.1.101/24 dev eth0 暂时配置网络地址</p>
<p>ip route addr default via 10.1.1.1 dev eth0 暂时配置网关</p>
<h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a><strong>日志管理</strong></h2><p>目录</p>
<p>/var/log</p>
<h3 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a><strong>日志分类</strong></h3><p>系统日志</p>
<p>登录日志         secure</p>
<p>程序日志</p>
<h3 id="日志服务配置文件"><a href="#日志服务配置文件" class="headerlink" title="日志服务配置文件"></a><strong>日志服务配置文件</strong></h3><p>/etc/rsyslog.conf</p>
<p>*.info;mail.none;authpriv.none;cron.none /var/log/messages</p>
<p>a.b</p>
<p>a:表示日历内容 , b:表示日志级别   /xx/x表示记录位置</p>
<h3 id="日志异地备份"><a href="#日志异地备份" class="headerlink" title="日志异地备份"></a><strong>日志异地备份</strong></h3>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux软件安装</title>
    <url>/2021/08/26/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>Linux软件安装</p>
<p>2021年8月26日</p>
<p>15:21</p>
<h3 id="linux软件分类"><a href="#linux软件分类" class="headerlink" title="linux软件分类"></a><strong>linux软件分类</strong></h3><p>源码包</p>
<p>封装后的软件包</p>
<span id="more"></span>

<p>在GNU社区下载</p>
<h4 id="源码包特点"><a href="#源码包特点" class="headerlink" title="源码包特点"></a><em><strong>源码包特点</strong></em></h4><ul>
<li>以压缩包形式提供</li>
<li>开源</li>
</ul>
<h4 id="安装压缩包的注意事项"><a href="#安装压缩包的注意事项" class="headerlink" title="安装压缩包的注意事项"></a><em><strong>安装压缩包的注意事项</strong></em></h4><ul>
<li>解包</li>
<li>编译 可以指定安装路径和编译所需功能</li>
<li>通过配置脚本指定安装路径和功能，并且生成makefile编译脚本文件</li>
<li>通过make命令控制makefile进行编译</li>
<li>makeinstall</li>
<li>将编译好的文件拷贝到安装路径下</li>
</ul>
<h5 id="封装软件包特点"><a href="#封装软件包特点" class="headerlink" title="封装软件包特点"></a><strong>封装软件包特点</strong></h5><p>后缀：rpm :red hat package manager只能在red hat上安装</p>
<p><code>    </code>deb : Debian                                  只能在Debian上安装</p>
<h4 id="安装封装软件包注意事项"><a href="#安装封装软件包注意事项" class="headerlink" title="安装封装软件包注意事项"></a><em><strong>安装封装软件包注意事项</strong></em></h4><ul>
<li>是否安装过该软件</li>
</ul>
<p>rpm-qa 列出所有安装过的rpm软件包</p>
<ul>
<li>确认该软件作用</li>
</ul>
<p>rpm -qpi xxxx.rpm</p>
<ul>
<li>确认软件安装路径</li>
</ul>
<p>rpm -qpl xxxx.rpm</p>
<ul>
<li>安装软件</li>
</ul>
<p>rpm -ivh xxx.rpm</p>
<ul>
<li>卸载软件</li>
</ul>
<p>rpm -e xxx</p>
<h4 id="根据光盘中依赖关系列表进行软件安装卸载-yum源安装"><a href="#根据光盘中依赖关系列表进行软件安装卸载-yum源安装" class="headerlink" title="根据光盘中依赖关系列表进行软件安装卸载(yum源安装)"></a><em><strong>根据光盘中依赖关系列表进行软件安装卸载(yum源安装)</strong></em></h4><ul>
<li>告诉操作系统依赖关系列表位置</li>
<li>通过yum工具进行软件卸载与安装</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcp_ip协议 12.1解决传输错误</title>
    <url>/2021/08/23/Tcp_ip%E5%8D%8F%E8%AE%AE%2012.1%E8%A7%A3%E5%86%B3%E4%BC%A0%E8%BE%93%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>12.1解决传输错误</p>
<p>2021年7月25日</p>
<p>21:57</p>
<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20210824133311.png" alt="大纲"></p>
<ul>
<li>问题提出与解决方案：</li>
</ul>
<p>在IP在路由中多级传输的过程时，我们会遇到诸如分组丢失，或者信息错误的问题。为了解决问题，可以使用数学上的通过冗余纠错。或者直接简单的尝试重复传递指定接收方到正确为止。这种方法称为ARQ(Automatic Repeat Request)</p>
<span id="more"></span>




<ul>
<li>解决方案正确性</li>
</ul>
<p>但是为了保证ARQ正确我们需要判断以下两个条件</p>
<ul>
<li>接收方是否收到分组</li>
<li>接收方收到分组是否与之前相同</li>
</ul>
<p>因此我们引入了ACK。</p>
<ul>
<li>ACK<ul>
<li>基本定义</li>
</ul>
</li>
</ul>
<p>为了解决以上两个问题接收方在接收到分组之后，需要向对方发送信确认接收。这种方法称为ACK(ackonwledgement)。</p>
<ul>
<li>实现方式</li>
</ul>
<p>发送方发送分组后等待ACK，直到接对方发送的对应ACK继续发送下一个分组。</p>
<p>但是这又引发了三个问题</p>
<ul>
<li>等待时间应该为多长</li>
<li>ACK同样可能丢失</li>
<li>分组接收到了，但是存在错误</li>
</ul>
<p>解决方法</p>
<ul>
<li>见14章现在，暂时不谈。</li>
<li>如果分组丢失，接收方无法发送ACK，发送方等同接收方未收到，会再次发送。但是这会使接收方获得同一份分组的多个拷贝。</li>
<li>通过前面的校验码验证错误，当错误时不发送ACK，直到发送方发送无措分组。</li>
</ul>
<p>通过ACK现在，我们可以确认接收方收到分组的正确。但是有可能收到多个相同分组。</p>
<p>我们可以使用序列号解决相同分组的问题，通过发送方唯一标识的序列号，接收方判断是否已经接收，如果接收则丢弃。</p>
<p>现在我们解决了正确性的问题，但是在时间上新的问题又出现了。由于每次分组都需要等待确认后，再发送下一个分组时间效率很低。因此我们需要同时在网络中发送多个分组，而由这新的问题又再次产生。</p>
<p>发送方需要确认同一时间应该在网络中保持多少分组正在发送，确认接收方发送分组的计时器应该是多少，需要保存多少副本以供分组丢失时以供重新传递。</p>
<p>同时接收方也需要判断接收分组的先后顺序，如果接收方或者路由器处理速度不够导致分组来不及处理就丢弃等问题。</p>
<p>为了解决所有的问题我们引入了分组窗口与滑动窗口。</p>
<p><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20210824133713.png" alt="滑动窗口"></p>
<ul>
<li>分组窗口与滑动窗口</li>
</ul>
<p>分组窗口定义：作为发送方已经发送但是还没有得到接收方ACK确认的分组的集合.</p>
<p>窗口大小：分组集合的大小。</p>
<p>通过右图我们可以观察到，在窗口左边的分组确认接收方已经收到，我们可以将对应的副本释放，而窗口右边则是仍未发送的分组。</p>
<p>每当发送方接收到一个分组ACK确认已经收到分组后，这整个窗口可以向右移动一位。因此这个协议也称为 <strong>滑动窗口协议</strong></p>
<ul>
<li>内存问题的解决</li>
</ul>
<p>通过滑动窗口发送方确认了对应内存的释放与分配，同时在接收方同样存在一个滑动窗口，在滑动窗口左侧的数据包已经被接受，中间的数据包正在等待接收，而右边的数据包既是接收了与会因为内存的限制而丢弃。</p>
<ul>
<li>变量窗口：流量和拥塞控制<ul>
<li>流量控制：</li>
</ul>
</li>
</ul>
<p>接收方通过发送一个与ACK一同传递的值W，告诉发送方应该实时调整窗口大小来保证接收方处理数据的效率与发送方匹配。而发送方在接收到ACK同时一起接收到了W,在窗口滑动的同时就调整了窗口大小。</p>
<ul>
<li>拥塞控制</li>
</ul>
<p>通过<strong>明确</strong>发信W我们保证了，发送方与接收方保持一致，但是在路由器的处理数度我们无法确认，因此我们需要一个<strong>隐形发信</strong>–涉及其他证据来决定减慢速度。这称为拥塞控制。详见16章</p>
<ul>
<li>关于重传超时的设定</li>
</ul>
<p>我们实时可以获取RTT(往返时间)作为平均值来判断是否重传，但是作为平均值通过它来判断，明显是不合理的可以遇见会有大量的数据包因为超时而重传。但是超时时间应该设定大于平均值多少在14章进一步讨论。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB服务配置</title>
    <url>/2021/08/29/WEB%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>WEB服务配置</p>
<p>2021年8月29日</p>
<p>9:26</p>
<h2 id="LAMP"><a href="#LAMP" class="headerlink" title="LAMP"></a><strong>LAMP</strong></h2><span id="more"></span>

<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a><strong>基本配置</strong></h3><h4 id="安装apache"><a href="#安装apache" class="headerlink" title="安装apache"></a><em><strong>安装apache</strong></em></h4><ul>
<li>安装httpd(apache) yum install httpd</li>
<li>打开httpd 服务 service start httpd</li>
<li>关闭防火墙 </li>
</ul>
<p>systemctl status firewalld.service</p>
<p>主页位置/var/www/html</p>
<p>主页配置文件 /etc/httpd/conf/httpd.conf</p>
<p>程序文件</p>
<p><code>         </code>监听端口</p>
<p><code>         </code>启动用户启动组 </p>
<p>User apache</p>
<p>Group apache</p>
<p><code>         </code>服务目录</p>
<p><code>                  </code>DocumentRoot “/var/www/html”</p>
<p><code>         </code>运行目录浏览</p>
<p><code>                 </code>Options Indexes FollowSymLinks</p>
<h3 id="访问控制设定"><a href="#访问控制设定" class="headerlink" title="访问控制设定"></a><strong>访问控制设定</strong></h3><p><code>        </code>Order allow,deny</p>
<p><code>                </code>Allow from 192.168.1.2 白名单</p>
<p>对页面进行加密，输入用户名密码才可进入</p>
<p><code>        </code>htpasswd -c /etc/httpd/conf/httpuser tom 建立用户tom</p>
<p><code>        </code>配置文件</p>
<p><code>        </code>authtype basic</p>
<p><code>        </code>authname “input username and password”</p>
<p><code>        </code>authuserfile /etc/httpd/conf/httpuser</p>
<p><code>        </code>require valid-user</p>
<h4 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a><em><strong>安装mysql</strong></em></h4><p>yum install mysql-server</p>
<p>启动</p>
<p><code> </code>service mysqld start</p>
<p>配置密码</p>
<p><code>        </code>mysqladmin -u root -p password “123.com”</p>
<p>进入</p>
<p><code>        </code>mysql -u root -p</p>
<h4 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a><em><strong>安装php</strong></em></h4><p>yum install php</p>
<p>yum install php-mysql 连接数据库插件</p>
<p>yum install php-mbstring</p>
<p>umount /dev/cdrom                卸下当前光盘</p>
<h5 id="配置php配置文件"><a href="#配置php配置文件" class="headerlink" title="配置php配置文件"></a><strong>配置php配置文件</strong></h5><p>目录 /etc/php.ini </p>
<p>开启短标签 short_open_tag = On</p>
<h2 id="LNMP"><a href="#LNMP" class="headerlink" title="LNMP"></a><strong>LNMP</strong></h2><h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a><strong>Nginx安装</strong></h2><p>yum install nginx</p>
<p>网站目录</p>
<p>/usr/share/nginx/html</p>
<p>配置文件</p>
<p><code> </code>/etc/nginx/nginx.conf)</p>
<p>关闭</p>
<p>nginx -s stop</p>
<h3 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a><strong>Nginx配置文件</strong></h3><p>全局配置</p>
<p>user nginx;          //运行用户</p>
<p>worker_processes auto;     //工作进程(根据cpu核心)</p>
<p>error_log /var/log/nginx/error.log;   // (错误文件)</p>
<p>pid /run/nginx.pid;                               //pid文件位置</p>
<p>I/O事件配置</p>
<p>events {</p>
<p><code>    </code>worker_connections 1024;     //每个进程处理连接数</p>
<p>}</p>
<p>HTTP配置</p>
<p>http{</p>
<p>***</p>
<p>}</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Me-and-My-girlfriend-1靶机</title>
    <url>/2021/08/31/Me-and-My-girlfriend-1%E9%9D%B6%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="靶场简介"><a href="#靶场简介" class="headerlink" title="靶场简介"></a>靶场简介</h3><p>下载地址：<a href="https://www.vulnhub.com/entry/me-and-my-girlfriend-1,409/">ME AND MY GIRLFRIEND: 1</a><br>目标:取得两个flag</p>
<span id="more"></span>
<p>用户:alice</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>VM2015<br>网上都是说选择NAT模式，尝试了一下在VM中选择VM1网段，但是用namp扫描不到。在虚拟机编辑选项里选择<strong>虚拟网络编辑器</strong>手动修改为启用DHCP，且将子网地址修改为与真实机相同网段后重启,再跑nmap就扫描到了。<br><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20210831222907.png" alt="虚拟机网络配置修改"></p>
<h3 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h3><p>先用nmap跑10.1.1网段，发现10.1.1.128开启22 和 80端口。明显一个网页服务一个SSH。<br><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20210831223129.png" alt="nmap扫描结果"><br>访问80端口显示仅由local本地地址可以进入。<br><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20210831223309.png" alt="网页结果"><br>查看源码后出现&lt;!– Maybe you can search how to use x-forwarded-for –&gt;提示。<br>搜了一下x-forwarded-for是记录最初的客户端ip以及后续代理ip。<br>语法:X-Forwarded-For: <client>, <proxy1>, <proxy2><br>很明显是通过伪造X-Forwarded-For为本地ip访问网站。<br>通过firefox Hackbar插件添加请求头 x-forwarded-for: 127.0.0.1，后即可正常访问。<br>进入网页后注册帐号，在profil页面发现通过GET方式user_id = 12，获得个人信息，尝试改变user_id是否可能获得其他人的帐号信息。<br>当我们输入id = 5时，用户名为alice,但是在密码页面无法直接看到，直接F12查看元素获得密码为:4lic3<br><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20210831224349.png" alt="密码"></p>
<p>用alice和 4lic3ssh连接，在/home/alice下存在隐藏文件._secret，进入文件夹后获得flag1.txt，然后通过命令sudo -l 发现 可以不使用密码 通过root权限使用php。<br>sudo php - r 使用root权限执行php命令，构造任意命令执行获得root权限.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo php -r <span class="string">&quot;system(&#x27;/bin/bash&#x27;);&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在 root 下搜索flag</span></span><br><span class="line"></span><br><span class="line">find / -name <span class="string">&quot;flag*.txt&quot;</span></span><br><span class="line"><span class="comment">#获得两个flag</span></span><br><span class="line">/root/flag2.txt</span><br><span class="line">/home/alice/.my_secret/flag1.txt</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>靶场</tag>
        <tag>Vulnhub</tag>
        <tag>Linux提权</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端基础</title>
    <url>/2021/09/03/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>前后端基础</p>
<p>2021年8月31日<span id="more"></span></p>
<p>14:13</p>
<ul>
<li>前端</li>
</ul>
<p># 表单</p>
<p>method属性:</p>
<p>get</p>
<p>url中显示数据</p>
<p>长度限制</p>
<p>Post</p>
<p>http请求</p>
<p>enctype属性</p>
<p>application/x-www-form-urlencoded         默认值</p>
<p>multipart/form-data         上传文件时，必需写</p>
<p>表单元素</p>
<p>&lt;input / &gt; 单标签</p>
<p>type                属性</p>
<p>password 不显示</p>
<p>text 文本框</p>
<p>radio 单选框         通过name指定相同的组</p>
<p>checkbox 复选框</p>
<p>reset 重置按钮</p>
<p>submit 提交按钮</p>
<p>file 文件域 在enctype=”multipart/form-data”条件下可用</p>
<p>hidden 隐藏输入文本框</p>
<p>value属性</p>
<p>传值</p>
<p>&lt;select&gt; 标签  </p>
<option value="0" selected = "selectd">选择月份</option>




<option> 1</option>

<option> 2</option>

<option> 3</option>

<option> 4</option>

<p>&lt;/select&gt; </p>
<p>文本域</p>
<p>&lt;textarea&gt; &lt;/textarea&gt;</p>
<p># iframe标签</p>
<p>属性</p>
<p>src iframe引用</p>
<ul>
<li>后端</li>
</ul>
<p>#PHP</p>
<p>php基本语法</p>
<ol>
<li>php结束标记?&gt;相当于;,因此最后一句php一句可以不加分号.</li>
<li>单行注释                //注释</li>
<li>多行注释                /* */</li>
<li>PHP代码中注释，不会显示在浏览器源码中</li>
<li>PHP脚本从上到下依次执行</li>
</ol>
<p>变量</p>
<p>变量申明</p>
<p>$abc = 123;</p>
<p>global $abc=1234;                //全局变量声明</p>
<p>static $abc=123;                 //静态变量，再函数内部声明，且仅在函数第一次执行是被初始化。</p>
<p>变量严格区分大小写</p>
<p>PHP为弱类型语言,不需要申明变量类型。</p>
<p>$c  = &amp; $a //c和a使用相同的内存空间，相当于给$a一个别名，两个变量实质上相同.</p>
<p>变量类型</p>
<ol>
<li>Bool                        echo输出false时，输出空白 </li>
</ol>
<p>以下所有值会为false</p>
<ol>
<li>false</li>
<li>0</li>
<li>0.0</li>
<li>空白字符串”” 和字符串0</li>
<li>没有成员的数组</li>
<li>NULL</li>
<li>int  整数</li>
<li>float 小数</li>
<li>string </li>
</ol>
<p>单引号定义字符串中’需要转义，$符号正常输出</p>
<p>双引号中’不需要转义正常输出，$符号代表变量的开始会输出变量</p>
<p>双引号中变量需要使用{}包裹,仅使用$无法判断变量的结束。</p>
<p>定界符  &lt;&lt;&lt;大写字母     //定界符开始</p>
<p>​                     大写字母;       //定界符和结束结束,分号之后不能接任何其他符号，如空格 tab 注释</p>
<p>在定界符中所有字符都会原样输出。</p>
<p>可变变量</p>
<p>$a = “change”</p>
<p>$$a = “xxxx”</p>
<p>—&gt; $change = “xxxx”</p>
<p>变量释放</p>
<p>unset</p>
<p>变量输出</p>
<ol>
<li>echo 输出变量内容</li>
<li>var_dump 输出变量类型及其内容</li>
</ol>
<p>常量</p>
<p>常量一旦被定义，无法被修改或者取消。</p>
<p>定义</p>
<p>define(“NAME”, “TEST!”);</p>
<p>一般名称为大写</p>
<p>预订义常量</p>
<p>__FILE__ 当前文件名</p>
<p>__LINEL__ 当前行数</p>
<p>__FUNCTION__ 当前函数名</p>
<p>__CLASS__ 当前类名</p>
<p>__METHOD__ 当前对象方法名<br>PHP_OS 当前操作系统</p>
<p>PHP_VERSION 当前PHP服务器版本</p>
<p>DIRECTORY_SEPARATOR 当前操作系统目录分隔符 / 或者\</p>
<p>运算符</p>
<p>其他运算符</p>
<p>? 三元运算符</p>
<p>   将字符串当作命令执行</p>
<p>@ 屏蔽提示,警告</p>
<p>流程控制</p>
<p>continue 和 break  后面可以接数字选择跳出几重循环</p>
<p>如 braek 2;</p>
<p>exit(“asdfasdf”); 结束脚本执行，同时输出字符串,如果括号内放置整数变量0-255,不会打印而是作为程序状态返回码。</p>
<p>die(); 结束脚本执行</p>
<p>函数</p>
<p>#形式</p>
<p>-——-</p>
<p>function name($xxx)</p>
<p>{</p>
<p>return;</p>
<p>}</p>
<p>-———</p>
<p>如果函数没有返回值，返回NULL。</p>
<p>#可变函数</p>
<p>函数名可以用变量，随着变量不同而运行不同的函数。</p>
<p>$name = ‘first’</p>
<p>$name(1234);</p>
<p>$name = ‘second’;</p>
<p>$name(1234);</p>
<p>$a($b) 是最简单的后门</p>
<p>可变函数不能用于例如 echo，print，unset()，isset()，empty()，include，require以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。 </p>
<p>#参数传递</p>
<p>应用传值function(&amp;$ x)</p>
<p>相当于直接调用内存空间</p>
<p>传参时可以申明默认值</p>
<p>function ($abc = 123)</p>
<p>当有多个参数时,有默认值的参数必须在无默认值的参数右侧。</p>
<p>funtion($x , $abc = 1234)</p>
<p>func_get_arg($int)  </p>
<p>通给传递 int参数从0下标开始获得传递参数</p>
<p>func_get_args()</p>
<p>获得参数数组</p>
<p>#常见函数</p>
<p>isset()          判断变量是否存在</p>
<p>move_uploaded_file($a, $b)    将a文件移动到b文件</p>
<p>数组</p>
<p>#数组创建</p>
<ol>
<li>array(“first”=&gt;”one” , “second”=&gt;”two”  );</li>
<li>$stu[] = 1; $stu[] = 2; $stu[] = 3;</li>
</ol>
<p>对应”key”可以为int 或者 stirng 类型， value 除了不能存放对象以为没有要求</p>
<p>在数组赋值过程中</p>
<p>字符串中的数字除非前面有+会自动变为int类型</p>
<p>float -&gt; int</p>
<p>bool - &gt; int </p>
<p>null -&gt; “”</p>
<p>数组可以key同时含有int 和 stirng </p>
<p>如果没指定key,PHP将会自动使用最大key+1作为新key</p>
<p>array(“a”, 4=&gt;”b”, “c”)</p>
<p>==&gt;</p>
<p>0 =&gt; “a”</p>
<p>4 = &gt; “b”</p>
<p>5 =&gt; “c”</p>
<p>#数组遍历</p>
<p>foreach($arr as $ value)</p>
<p>$value = xxx;</p>
<p>foreach($arr as $key =&gt; $value)</p>
<p>$key =&gt; $value ;                 //    1=&gt; “first” , “two” =&gt; “second”</p>
<p>数组遍历最后一个$value并不会被销毁</p>
<p>#预订义PHP全局超数组变量</p>
<p>$GLOBALS        引用全局作用域中的全步可变变量</p>
<p>$_SERVER        包含了诸如头信息(header)、路径(path)、等等信息的数组</p>
<p>$_GET           URL通过GET方式传递参数</p>
<p>$_PSOT          通过POST方式传递参数</p>
<p>$_FILE          过 HTTP POST 方式上传到当前脚本的项目的数组</p>
<p>$_SESSION       当前脚本可用 SESSION 变量的数组</p>
<p>$_COOKIE        通过 HTTP Cookies 方式传递给当前脚本的变量的数组。</p>
<p>$_REQUEST       默认情况下包含了 $_GET，$_POST 和 $_COOKIE 的数组。 </p>
<p>$_ENV           通过环境方式传递给当前脚本的变量的数组。 </p>
<p>COOKIE</p>
<p>​      每次客户端浏览，服务器都会向客户端发送Cookie</p>
<p>​      键值对</p>
<p>​      #性质</p>
<p>​          name    Cookie的名称</p>
<p>​          value   值</p>
<p>​          expire  过期时间</p>
<p>​          path    有效路径</p>
<p>​          domain  域名</p>
<p>​          secure  是否仅在HTTPS下设置Cookie</p>
<p>​          httplnoly 仅通过http协议访问,不能通过JS协议访问</p>
<p>​      #设置Cookie</p>
<p>​          setcookie();</p>
<p>​      #注销Cookie</p>
<p>​          setcookie(*, *, *, time()-3600)    //设置cookie过期时间为之前</p>
<p>session 机制</p>
<p>​      依赖Cookie 实现</p>
<p>​      session_start()        创建新的会话</p>
<p>​      session_destory()      服务器删除session缓存中全部数据。但是Cookie信息依然存在</p>
<p>​      session文件存储位置                 /phpstudy/tep/tep</p>
<p>​      $_SESSION              修改session文件中的值</p>
<p>PHP与mysql交互</p>
<p>​      1. 建立连接</p>
<p>​           用户名</p>
<p>​           密码</p>
<p>​           地址</p>
<p>​               数据库名</p>
<p>​      2. 执行SQL语句</p>
<p>​      3. 断开连接</p>
<p>​      连接相关函数</p>
<p>​          $link = mysqli_connect($dbHost, $dbUser, $dbPass, $dbName);    //连接数据库</p>
<p>​          mysqli_connect_error();    //返回一个字符串描述最后一次连接调用代码</p>
<p>​          mysqli_close($link);       //关闭连接</p>
<p>​          mysqli_query($link , $sql)   //查询语句返回对象</p>
<p>​          mysqli_fetch_assoc($results) //从结果对象取出一条记录返回结果数组</p>
<p>​          mysqli_error($link)          //返回最近函数调用错误</p>
<p>​          mysqli_num_rows()            //取出结果集中行的数量</p>
<p>JavaScript</p>
<p>​      简单语句</p>
<p>​          alert();          //弹窗</p>
<p>​          console.log()     //在控制台输出</p>
<p>​      在HTML语句中插入JS代码</p>
<p>​          <script> </script></p>
<p>​          <script src="xxx.js"></script></p>
<p>​      变量</p>
<p>​          var xx = 1234;</p>
<p>​          由于JS的设计缺陷，当变量不用var 声明默认为全局变量。</p>
<p>​          如果启用strict模式，系统强制使用var 申明变量。</p>
<p>​      数组</p>
<p>​          声明  var tem = [1 , 2.0 , “1214” ,null, tree];</p>
<p>​      对象</p>
<p>​          JS所有操作都是通过对象实现的</p>
<p>​          JS对象是由键值对组成的无序集合，键为字符串 值为任意类型。</p>
<p>​          var x = { name: ‘bob’, age: 30};</p>
<p>​          访问  x.key </p>
<p>​      流程控制</p>
<p>​          for(var key in 对象)</p>
<p>​              将对象所有属性依次循环。</p>
<p>​      函数</p>
<p>​          定义</p>
<p>​              1. function abs(x)</p>
<p>​      常用对象</p>
<p>​          window:充当全局作用域,代表浏览器窗口</p>
<p>​          navigator:浏览器信息</p>
<p>​              常用属性</p>
<p>​                  .appName:浏览器名称</p>
<p>​                  .appVersion:浏览器版本</p>
<p>​     .language:浏览器语言</p>
<p>​     .platform:操作系统</p>
<p>​     .userAgent:浏览器User_Agent字符串</p>
<p>​          location:URL信息</p>
<p>​              location.assign()    加载新页面</p>
<p>​              location.reload()    重新加载页面</p>
<p>​          document:浏览器以DOM树解释整个HTML页面，DOM树的根节点</p>
<p>​              .getElementById()    根据Id查询DOM节点</p>
<p>​        .getElementByTagName()     根据name查询DOM节点</p>
<p>​        .getElementByClassName()    CSS选择器</p>
<p>​        var test = document.getElementById(‘test’);</p>
<p>​        var cs = test.children;     获得test的所有直属子节点</p>
<p>​        var first  = test.firstElementChild    获取第一子节点</p>
<p>​        querySelector();     根据selector语法获取节点</p>
<p>​              document.Cookie:可以完成Cookie信息的读取</p>
<p>​                  document.cookie = “name= helllo”</p>
<p>事件</p>
<p>​       事件类型</p>
<p>​          鼠标事件</p>
<p>​              onclick</p>
<p>​          键盘事件</p>
<p>​          form事件</p>
<p>​        事件相应</p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcp_ip协议 12.2TCP的引入</title>
    <url>/2021/09/03/Tcp_ip%E5%8D%8F%E8%AE%AE%2012.2TCP%E7%9A%84%E5%BC%95%E5%85%A5/</url>
    <content><![CDATA[<p>12.2 TCP的引入</p>
<span id="more"></span>

<p>2021年9月3日</p>
<p>21:05</p>
<p><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20210903213842.png" alt="TCP头部在数据包中封装"></p>
<p><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20210903213934.png" alt="TCP头部信息"></p>
<ul>
<li>TCP头部包含源端口和目标端口。端口和IP唯一标识了每个TCP连接，端口IP的组合有时被称为socket。   4字节</li>
<li>序列号标记了这一段信息中第一个字节的编号 4字节</li>
<li>ACK(确认号)为最后接收到的字节的序列号+1.  4字节</li>
<li>头部长度以32位字(4字节)为单位确定4位标识位，TCP头部最多带60字节头部.   头部长度加上保留 共 1字节</li>
<li>8种状态位     1字节</li>
<li>窗口大小      2字节</li>
<li>TCP校验      2字节</li>
<li>紧急指针      2字节 //仅在URG字段设置时有效</li>
</ul>
<ol>
<li>SYN状态位，在建立连接时使用</li>
<li>FIN状态位, 当关闭连接时使用</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP核心配置</title>
    <url>/2021/09/04/PHP%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>PHP核心配置</p>
<span id="more"></span>

<p>2021年7月13日</p>
<p>10:58</p>
<ul>
<li>配置的可修改范围</li>
</ul>
<p>PHP_INI_USER        可在用户脚本（例如 ini_set()）或 Windows 注册表（自 PHP 5.3 起）以及 .user.ini 中设定 </p>
<p>PHP_INI_PERDIR        可在 php.ini，.htaccess 或 httpd.conf 中设定</p>
<p>PHP_INI_SYSTEM        可在 php.ini 或 httpd.conf 中设定</p>
<p>PHP_INI_ALL        可在任何地方设定</p>
<p>php.ini only    仅在php.ini中设置</p>
<ul>
<li>核心配置选项<ul>
<li>register_globals</li>
</ul>
</li>
</ul>
<p>说明:该选项在on情况下，会将用户GET,POST提交上的参数自动注册为全局变量，并且初始化为对应的值。</p>
<p>版本变换:PHP &lt;= 4.2.3范围为PHP_INI_ALL, 在PHP5.3.0开始默认关闭 ， PHP 5.4.0移除该选项。</p>
<p>例子:</p>
<?php

if($user=admin)

echo 123;

?>

<p>xx.php?user=admin运行时会输出123</p>
<ul>
<li>allow_url_include</li>
</ul>
<p>说明:开启情况下，运行包含远程文件.</p>
<p>版本变化: PHP 5.2.0后默认关闭</p>
<ul>
<li>magic_quotes_gpc</li>
</ul>
<p>说明:开启后会在GET , POST, COOKIE 变量中 ‘ “  \ null 字符前加入,但是并不会过滤$_SERVER变量。</p>
<p>版本变化:PHP 5.3后默认关闭 , 5.4之后取消 ， 在&lt;=4.2.3时,配置范围为 PHP_INI_ALL</p>
<ul>
<li>magic_quotes_runtime</li>
</ul>
<p>说明:与_gpc相同，只不过只对文件和数据库中获取的数据转义。</p>
<p>版本变化:5.4后取消</p>
<p>特点:只有部分函数受影响</p>
<ul>
<li>magic_quotes_sybase</li>
</ul>
<p>说明:会将GET,POST, Cookie的传递的单引号(‘)变为(“)，并转义null字符.</p>
<p>配置范围: PHP_INI_ALL</p>
<p>版本: 5.4.0后移除</p>
<p>特点:当开启后会覆盖_gpc = on;</p>
<ul>
<li>safe_mode(安全模式)</li>
</ul>
<p>配置范围:PHP_INI_SYSTEM</p>
<p>版本: 5.4.0之后被取消</p>
<p>说明:</p>
<ul>
<li><p>所有文件操作会受限制</p>
</li>
<li><p>popen(), system(), exec()等命令执行函数会受限制</p>
</li>
<li><p>open_basedir</p>
</li>
</ul>
<p>说明:限制PHP可以访问的目录</p>
<p>配置范围:&lt;2.2.3 PHP_INI_SYSTEM ，  &gt;= 5.2.3 PHP_INI_ALL</p>
<p>特点:对于目录要以/闭合，如 open_basedir = www/a,那么可以访问www/a 和www/b。</p>
<p>因此合理的写法为www/a/</p>
<ul>
<li>diable_functions</li>
</ul>
<p>说明:禁止php函数应用</p>
<p>范围:php.ini</p>
<ul>
<li>display_errors  , error_reporting</li>
</ul>
<p>说明:关闭 _errors关闭会取消错误显示，当开启时配合_reporting可以控制错误显示级别.</p>
<p>配置范围:PHP_INI_ALL</p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcp_ip协议 13.2连接的建立和终止</title>
    <url>/2021/09/06/Tcp_ip%E5%8D%8F%E8%AE%AE%2013.2%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%88%E6%AD%A2/</url>
    <content><![CDATA[<h1 id="13-2-TCP-IP连接的建立和终止"><a href="#13-2-TCP-IP连接的建立和终止" class="headerlink" title="13.2 TCP_IP连接的建立和终止"></a>13.2 TCP_IP连接的建立和终止</h1><span id="more"></span>

<h2 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h2><p><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20210906220930.png" alt="建立连接"></p>
<ol>
<li>主动开启者发送报文，包含初始序列号ISN_c,SYN位表示想要建立TCP连接</li>
<li>服务器SYN报文seq = $INS_x$, ACK=$INS_c$+1，表示服务器确认建立连接。此时<strong>服务器</strong>知道<strong>服务器接受</strong>功能无问题、<strong>客户端发送</strong>无问题</li>
<li>客户端发送ACK报文，seq = $INS_c+1$, ACK = $INS_x+1$。当客户端接受到2号报文时，<strong>客户端</strong>确认<strong>双方发送接受</strong>均无问题。当<strong>服务端</strong>接受到报文3时确认<strong>服务端发送客户端接受</strong>无问题。</li>
</ol>
<h2 id="连接关闭"><a href="#连接关闭" class="headerlink" title="连接关闭"></a>连接关闭</h2><p><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20210906221028.png" alt="连接关闭"></p>
<ol>
<li>主动开启者发送    Fin段以及$Seq = k, ACK = L$。表示想要关闭连接。</li>
<li>被动开启者发送 $Seq = L, ACK = k+1$，表示接收到关闭帧。</li>
<li>如果有数据还需要发送，进行剩余的数据发送</li>
<li>被动开启者发送$Fin Seq = L , ACK = k+1$，表示关闭连接。</li>
<li>主动开启者发送$Seq = k+1，  ACK = L+1 $，接收到被动方的连接关闭。</li>
</ol>
<h2 id="TCP半关闭"><a href="#TCP半关闭" class="headerlink" title="TCP半关闭"></a>TCP半关闭</h2><p>含义：半关闭表示为一方发送Fin连接表示我已经发送了所有我应该发送的数据，但是我仍然希望接收对方发送的数据直到对方发送Fin连接。表示对方数据同样发送完毕。</p>
<p>整体流程与TCP关闭相同不过在第三步会发送更多的数据。</p>
<h2 id="同时打开与同时关闭"><a href="#同时打开与同时关闭" class="headerlink" title="同时打开与同时关闭"></a>同时打开与同时关闭</h2><p><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20210906221113.png"></p>
<p><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20210906221145.png"></p>
<p>当双方同时向对方发送清求连接或者请求关闭连接时，会发生这种情况。此时无论建立连接或者关闭连接都会发送4个报文。</p>
<h2 id="连接建立超时"><a href="#连接建立超时" class="headerlink" title="连接建立超时"></a>连接建立超时</h2><p>当向无法回复的服务器请求建立连接时，客户端会不断向服务器发送SYN报文。时间上采取<strong>指数回退</strong>。第二次发送报文3秒后，第三次在上一个报文发送6秒后，第四次在上一次发送12秒后。以此类推，同时可以控制尝试发送SYN连接报文的最多次数。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title>msyql宽字节注入</title>
    <url>/2021/09/16/msyql%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="mysql宽字节注入"><a href="#mysql宽字节注入" class="headerlink" title="mysql宽字节注入"></a>mysql宽字节注入</h1><span id="more"></span>

<p>  #宽字节注入</p>
<p>  在注入过程中，如果采用magic_quot_gpc 或者 addslashes()。如果采用’注入会产生&#39;。导致无法绕过’’。当采用客户端采用 SET names = GBK 或者 mysqli_set_charset($conn, ‘gbk’)时，相当于设置 </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET character_set_connection=gbk, character_set_results=gbk,character_set_client=binary</span><br></pre></td></tr></table></figure>

<p>此时转义字符\被URL编码解析为 %5c 如果我们手动输入 %df’。经过浏览器编码和转义后会成为 %df%5c%27。在[[msyql数据编码]]的设置下,%df%5c 连接在一起会被解析为GBK双字节编码,此时%df\会变为一个汉字。因此我们便绕过了\转义符,实现了在mysql语句中直接插入’的目的。在绕过的过程中%df不固定，只要可以与%5c一起构成GBK编码都可以绕过\转义符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//echo 12341234;</span><br><span class="line"></span><br><span class="line">	function unicode($res)</span><br><span class="line">	&#123;</span><br><span class="line">		//echo 1234;</span><br><span class="line">		 //print&quot;12421&quot;;</span><br><span class="line">			 while($val=mysqli_fetch_row($res))&#123;</span><br><span class="line">   			 print&quot;&#123;$val[0]&#125; = &#123;$val[1]&#125;&quot;;</span><br><span class="line">   			  print(&quot;&lt;br&gt;&quot;);</span><br><span class="line">			 &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//echo 1234555;</span><br><span class="line">	header(&quot;Content-Type:text/html;charset=gbk&quot;); //为了显示，将页面默认为gbk</span><br><span class="line">	$name=$_GET[&#x27;name&#x27;];</span><br><span class="line">		echo $name;</span><br><span class="line">	echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">	$conn = mysqli_connect(&#x27;127.0.0.1&#x27;,&#x27;root&#x27;,&#x27;root&#x27;);  </span><br><span class="line">	mysqli_select_db($conn,&#x27;xnfh&#x27;);</span><br><span class="line">	</span><br><span class="line">	print&quot;****************&lt;br&gt;AT Start &lt;br&gt;&quot;;</span><br><span class="line">	</span><br><span class="line">	$result=mysqli_query($conn,&quot;show variables like &#x27;character\_set\_%&#x27;;&quot;);</span><br><span class="line">	unicode($result);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//mysqli_set_charset($conn, &#x27;gbk&#x27;);</span><br><span class="line">	//mysqli_query($conn,&quot;set names &#x27;gbk&#x27;&quot;);</span><br><span class="line">	mysqli_query($conn, &quot;SET character_set_connection=gbk, character_set_client=gbk&quot;);</span><br><span class="line">	print&quot;*********************** &lt;br&gt;charset gbk &lt;br&gt;&quot;;</span><br><span class="line">		$result=mysqli_query($conn,&quot;show variables like &#x27;character\_set\_%&#x27;;&quot;);</span><br><span class="line">	unicode($result);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">		mysqli_query($conn, &quot;SET character_set_connection=gbk, character_set_results=gbk,character_set_client=binary&quot;);</span><br><span class="line">		print&quot;*********************** &lt;br&gt;charset gbk and protect &lt;br&gt;&quot;;</span><br><span class="line">		$result=mysqli_query($conn,&quot;show variables like &#x27;character\_set\_%&#x27;;&quot;);</span><br><span class="line">	unicode($result);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//$name = mysqli_real_escape_string($conn, $name);</span><br><span class="line">	$name =addslashes($name);</span><br><span class="line">	//echo 1234;</span><br><span class="line">	//mysqli_query($conn,&quot;character_set_client=binary&quot;);</span><br><span class="line">	</span><br><span class="line">	//mysqli_query($conn,&quot;SET character_set_connection=gbk,character_set_client=binary&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	echo $name;</span><br><span class="line">	echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">	//mysqli_query($conn,&quot;SET NAMES &#x27;gbk&#x27;&quot;);</span><br><span class="line">	if($conn==null)&#123;exit(&quot;connect error !&lt;br&gt;&quot;);&#125;</span><br><span class="line">	$sql=&quot;select * from users where id=&#x27;&quot;.$name.&quot;&#x27;&quot;;</span><br><span class="line">	$result2=mysqli_query($conn,$sql);</span><br><span class="line">	unicode($result2);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	echo $sql;</span><br><span class="line">	echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">	//echo 1234;</span><br><span class="line">	unicode($result);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>



<p>经过实验代码我们发现，直接设置 SET NAMES gbk 与  mysqli_set_charset 在直接结果上都是相同的 ,都只改变3项为gbk.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT Start</span><br><span class="line"></span><br><span class="line">character_set_client = utf8</span><br><span class="line">character_set_connection = utf8</span><br><span class="line">character_set_database = utf8</span><br><span class="line">character_set_filesystem = binary</span><br><span class="line">character_set_results = utf8</span><br><span class="line">character_set_server = utf8</span><br><span class="line">character_set_system = utf8</span><br><span class="line">***********************</span><br><span class="line">After charset gbk</span><br><span class="line"></span><br><span class="line">character_set_client = gbk		//改变</span><br><span class="line">character_set_connection = gbk	//改变</span><br><span class="line">character_set_database = utf8</span><br><span class="line">character_set_filesystem = binary</span><br><span class="line">character_set_results = gbk	//改变</span><br><span class="line">character_set_server = utf8</span><br><span class="line">character_set_system = utf8</span><br></pre></td></tr></table></figure>

<p>防御方法 </p>
<ol>
<li><p>通过mysqli_set_charset 与 mysql_real_escape_string()转义达到效果，放弃add….()函数。</p>
<pre><code>通过mysqli_set_charse设置字符集之后，使用real_escape()函数会根据对应设置的字符集进行相应的转义，虽然字符集设计没有改变，但是无法绕过\转义符.
</code></pre>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mysqli_set_charset(<span class="variable">$conn</span>, <span class="string">&#x27;gbk&#x27;</span>);</span><br><span class="line"><span class="variable">$name</span> = mysqli_real_escape_string(<span class="variable">$conn</span>, <span class="variable">$name</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>通过设置 character_set_client = binary改变字符集编码，连接时不使用GBK编码，从而无法绕过\。</p>
<pre><code>我试了一下发现单单使用character_set_client = binary，无法防御注入同时查询当前的数据库编码也没有任何的改变，至少要使用 set_client 与 set_connection 两项才可以保护。具体原理以后再说吧,
</code></pre>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;SET character_set_connection=gbk, ,character_set_client=binary</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>在最后我发现只要使用<code>mysqli_query($conn, &quot;SET character_set_connection=gbk, character_set_client=gbk&quot;);</code>就会导致宽字节注入，具体的原理还是等弄懂[[msyql数据编码]]以后在说。</p>
]]></content>
      <categories>
        <category>注入</category>
      </categories>
      <tags>
        <tag>宽字节注入</tag>
        <tag>mysql</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>NARAK靶机</title>
    <url>/2021/12/12/NARAK%E9%9D%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="靶场简介"><a href="#靶场简介" class="headerlink" title="靶场简介"></a>靶场简介</h1><p>靶机地址：<a href="https://www.vulnhub.com/entry/ha-narak,569/">NARAK</a><br>目标:user.txt , root.txt</p>
<span id="more"></span>


<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>使用namp 扫描10.1.1.0/24网段，发现靶机地址为10.1.1.129。<br>开放22端口和80端口。<br><img src="https://raw.githubusercontent.com/sincelong/BlogImage/main/img/20211212160132.png" alt="靶机扫描"><br>进入网页后发现，都是图片没有什么有用的信息。<br>使用dirb扫描靶机后发现存在三个目录<br><code>dirb http://10.1.1.129</code></p>
<ul>
<li>/index.html</li>
<li>/server-startus</li>
<li>/webdav</li>
</ul>
<p>index为主页，server-startus没有足够的权限，webdav需要帐号密码才能够查看。目前来看唯一可行的只有通过webdav进入。<br>使用cewl 对index网页进行爬虫，得到可能的密码字典，然后使用hydra进行爆破尝试.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cewl -w password.txt http://10.1.1.129</span><br><span class="line">hydra -L password.txt -P password.txt 10.1.1.129 http-get /webdav</span><br></pre></td></tr></table></figure>

<p>得到 yamdoot:Swarg账户。尝试之后无法使用ssh登录。使用cadaver 连接webdav,然后put一个webshell进去。反弹shell后，使用<code>python3 -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code>得到一个交互式bash窗口。  </p>
<p>但是我们只有www-data权限，到home后我们得到了 inferno narak yamdoot 三个用户，试试用之前的密码连接全部失败了.又尝试进入mnt中发现有一个hell.sh文件，其中的内容为<br>    echo”Highway to Hell”;<br>    –[—–&gt;+&lt;]&gt;—.+++++.+.+++++++++++.–.+++[-&gt;+++&lt;]&gt;++.++++++.–[—&gt;+&lt;]&gt;–.—–.++++.</p>
<p>其中的信息使用了brainfuck进行加密，到<a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a> 进解码后，得到了 <strong>chitragupt</strong> 。<br>再次尝试使用三个帐号登录，这一次inferno帐号登录成功我们在home中得到了user.txt.很明显root.txt需要提权后得到。<br>使用motc提权</p>
<ol>
<li>进入文件夹 /etc/update-motd.d/</li>
<li>修改文件 echo “echo ‘root:admin2’|sudo chpasswd” &gt;&gt; 00-header</li>
<li>重新登录</li>
<li>su root 密码为admin</li>
</ol>
<p>其中00-header文件的执行权限为root，但是我们可以对它进行修改意味着当文件执行时可以用root权限运行。00-header文件相当于登录的欢迎文件，当我们重新登录时 附加进的 echo ‘root:admin’|sudo chpasswd相当于使用root权限进行 chpasswd命令，而 | 前的相当于指令的输入，因此root的密码被修改为admin。从而获得root权限<br>在root文件夹中获得root.txt。</p>
<hr>
]]></content>
      <categories>
        <category>靶场</category>
      </categories>
      <tags>
        <tag>靶场</tag>
        <tag>Vulnhub</tag>
        <tag>Linux提权</tag>
        <tag>爬虫字典</tag>
      </tags>
  </entry>
</search>
